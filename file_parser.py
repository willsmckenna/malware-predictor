####################################################################################################
# file_parser.py- used in SE526 final project, modified as needed throughout project to 
# collect the different files. It goes through a directory of files and collects data 
# into a csv file that is later used for machine learning.
####################################################################################################
import pefile
import os
import math
import mmap
import sys

from datetime import datetime

import logging



def force_decode(string, codecs=["utf8", "cp1252"]):
    for i in codecs:
        try:
            return string.decode(i)
        except UnicodeDecodeError:
            pass


# Calculating entropy- from https://kennethghartman.com/calculate-file-entropy/
def calculate_entropy(filepath):
    # read the whole file into a byte array
    f = open(filepath, "rb")
    byteArr = f.read()
    f.close()
    fileSize = len(list(byteArr))

    # calculate the frequency of each byte value in the file
    freqList = []
    for b in range(256):
        ctr = 0
        for byte in byteArr:
            if byte == b:
                ctr += 1
        freqList.append(float(ctr) / fileSize)
    # print 'Frequencies of each byte-character:'
    # print freqList
    # print

    # Shannon entropy
    ent = 0.0
    for freq in freqList:
        if freq > 0:
            ent = ent + freq * math.log(freq, 2)
    ent = -ent

    return ent


directory = os.fsdecode("C:\\Users\\wills\\Desktop\\exegroup")

outFile = open("C:\\Users\\wills\\Desktop\\OutFile-Not-Malware3.txt", "w")

for file in os.listdir(directory):
    filename = os.fsdecode(file)
    if filename.endswith('.exe'):
        print(filename)
        file_path = r"C:\Users\wills\Desktop\exegroup\{}".format(filename)
        print(file_path)
        fd = open(file_path, "rb")
        pe_data = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_READ)
        pe = pefile.PE(data=pe_data)

        # getting PE section names for the file
        section_names = []

        for section in pe.sections:
            section_name = force_decode(section.Name)
            section_names.append(section_name)

        # getting the entropy of the file
        entropy = calculate_entropy(file_path)
        # PE header info
        machine = pe.FILE_HEADER.Machine
        time_date_stamp = pe.FILE_HEADER.dump_dict()["TimeDateStamp"]["Value"].split("[")[
            1
        ][:-1]
        number_of_sections = pe.FILE_HEADER.NumberOfSections
        characteristics = pe.FILE_HEADER.Characteristics
        # Optional header info
        image_base = pe.OPTIONAL_HEADER.ImageBase
        section_allign = pe.OPTIONAL_HEADER.SectionAlignment
        file_allign = pe.OPTIONAL_HEADER.FileAlignment
        size_of_image = pe.OPTIONAL_HEADER.SizeOfImage
        dll_chars = pe.OPTIONAL_HEADER.DllCharacteristics

        # put it all on one comma seperated line
        line = ""
        line += "(" + " ".join(section_names) + "),"
        line += str(entropy) + ","
        line += str(machine) + ","
        line += str(time_date_stamp) + ","
        line += str(number_of_sections) + ","
        line += str(image_base) + ","
        line += str(section_allign) + ","
        line += str(file_allign) + ","
        line += str(size_of_image) + ","
        line += str(dll_chars)

        # write it to file
        outFile.write(line)
        outFile.write("\n")
